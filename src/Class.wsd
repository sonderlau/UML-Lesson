@startuml "类图"
namespace chunkserver {
    class ChunkServer  {
        - lock sync.RWMutex
        - address gfs.ServerAddress
        - master gfs.ServerAddress
        - rootDir string
        - l net.Listener
        - shutdown <font color=blue>chan</font> <font color=blue>struct</font>{}
        - dl *downloadBuffer
        - chunk <font color=blue>map</font>[gfs.ChunkHandle]*chunkInfo
        - dead bool
        - pendingLeaseExtensions *util.ArraySet
        - garbage []gfs.ChunkHandle

        - heartbeat() error
        - garbageCollection() error
        - loadMeta() error
        - storeMeta() error
        - writeChunk(handle gfs.ChunkHandle, data []byte, offset gfs.Offset, lock bool) error
        - readChunk(handle gfs.ChunkHandle, offset gfs.Offset, data []byte) (int, error)
        - deleteChunk(handle gfs.ChunkHandle) error
        - doMutation(handle gfs.ChunkHandle, m *Mutation) error
        - padChunk(handle gfs.ChunkHandle, version gfs.ChunkVersion) error

        + RPCReportSelf(args gfs.ReportSelfArg, reply *gfs.ReportSelfReply) error
        + Shutdown() 
        + RPCCheckVersion(args gfs.CheckVersionArg, reply *gfs.CheckVersionReply) error
        + RPCForwardData(args gfs.ForwardDataArg, reply *gfs.ForwardDataReply) error
        + RPCCreateChunk(args gfs.CreateChunkArg, reply *gfs.CreateChunkReply) error
        + RPCReadChunk(args gfs.ReadChunkArg, reply *gfs.ReadChunkReply) error
        + RPCWriteChunk(args gfs.WriteChunkArg, reply *gfs.WriteChunkReply) error
        + RPCAppendChunk(args gfs.AppendChunkArg, reply *gfs.AppendChunkReply) error
        + RPCApplyMutation(args gfs.ApplyMutationArg, reply *gfs.ApplyMutationReply) error
        + RPCSendCopy(args gfs.SendCopyArg, reply *gfs.SendCopyReply) error
        + RPCApplyCopy(args gfs.ApplyCopyArg, reply *gfs.ApplyCopyReply) error
        + PrintSelf(no1 gfs.Nouse, no2 *gfs.Nouse) error

    }
    class Mutation  {
        - mtype gfs.MutationType
        - data []byte
        - offset gfs.Offset

    }
    class chunkInfo  {
        - length gfs.Offset
        - version gfs.ChunkVersion
        - checksum gfs.Checksum
        - mutations <font color=blue>map</font>[gfs.ChunkVersion]*Mutation
        - abandoned bool

    }
    class downloadBuffer  {
        - buffer <font color=blue>map</font>[gfs.DataBufferID]downloadItem
        - expire time.Duration
        - tick time.Duration

        + Set(id gfs.DataBufferID, data []byte) 
        + Get(id gfs.DataBufferID) ([]byte, bool)
        + Fetch(id gfs.DataBufferID) ([]byte, error)
        + Delete(id gfs.DataBufferID) 

    }
    class downloadItem  {
        - data []byte
        - expire time.Time

    }
}
"sync.RWMutex" *-- "chunkserver.chunkInfo"
"sync.RWMutex" *-- "chunkserver.downloadBuffer"


namespace client {
    class Client  {
        - master gfs.ServerAddress
        - leaseBuf *leaseBuffer

        + Create(path gfs.Path) error
        + Delete(path gfs.Path) error
        + Rename(source gfs.Path, target gfs.Path) error
        + Mkdir(path gfs.Path) error
        + List(path gfs.Path) ([]gfs.PathInfo, error)
        + Read(path gfs.Path, offset gfs.Offset, data []byte) (int, error)
        + Write(path gfs.Path, offset gfs.Offset, data []byte) error
        + Append(path gfs.Path, data []byte) (gfs.Offset, error)
        + GetChunkHandle(path gfs.Path, index gfs.ChunkIndex) (gfs.ChunkHandle, error)
        + ReadChunk(handle gfs.ChunkHandle, offset gfs.Offset, data []byte) (int, error)
        + WriteChunk(handle gfs.ChunkHandle, offset gfs.Offset, data []byte) error
        + AppendChunk(handle gfs.ChunkHandle, data []byte) (gfs.Offset, error)

    }
    class leaseBuffer  {
        - master gfs.ServerAddress
        - buffer <font color=blue>map</font>[gfs.ChunkHandle]*gfs.Lease
        - tick time.Duration

        + Get(handle gfs.ChunkHandle) (*gfs.Lease, error)

    }
}
"sync.RWMutex" *-- "client.leaseBuffer"


namespace gfs {
    class AppendChunkArg << (S,Aquamarine) >> {
        + DataID DataBufferID
        + Secondaries []ServerAddress

    }
    class AppendChunkReply << (S,Aquamarine) >> {
        + Offset Offset
        + ErrorCode ErrorCode

    }
    class ApplyCopyArg << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + Data []byte
        + Version ChunkVersion

    }
    class ApplyCopyReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode

    }
    class ApplyMutationArg << (S,Aquamarine) >> {
        + Mtype MutationType
        + DataID DataBufferID
        + Offset Offset

    }
    class ApplyMutationReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode

    }
    class CheckVersionArg << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + Version ChunkVersion

    }
    class CheckVersionReply << (S,Aquamarine) >> {
        + Stale bool

    }
    class CreateChunkArg << (S,Aquamarine) >> {
        + Handle ChunkHandle

    }
    class CreateChunkReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode

    }
    class CreateFileArg << (S,Aquamarine) >> {
        + Path Path

    }
    class CreateFileReply << (S,Aquamarine) >> {
    }
    class DataBufferID << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + TimeStamp int

    }
    class DeleteFileArg << (S,Aquamarine) >> {
        + Path Path

    }
    class DeleteFileReply << (S,Aquamarine) >> {
    }
    class Error << (S,Aquamarine) >> {
        + Code ErrorCode
        + Err string

        + Error() string

    }
    class ExtendLeaseArg << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + Address ServerAddress

    }
    class ExtendLeaseReply << (S,Aquamarine) >> {
        + Expire time.Time

    }
    class ForwardDataArg << (S,Aquamarine) >> {
        + DataID DataBufferID
        + Data []byte
        + ChainOrder []ServerAddress

    }
    class ForwardDataReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode

    }
    class GetChunkHandleArg << (S,Aquamarine) >> {
        + Path Path
        + Index ChunkIndex

    }
    class GetChunkHandleReply << (S,Aquamarine) >> {
        + Handle ChunkHandle

    }
    class GetFileInfoArg << (S,Aquamarine) >> {
        + Path Path

    }
    class GetFileInfoReply << (S,Aquamarine) >> {
        + IsDir bool
        + Length int64
        + Chunks int64

    }
    class GetPrimaryAndSecondariesArg << (S,Aquamarine) >> {
        + Handle ChunkHandle

    }
    class GetPrimaryAndSecondariesReply << (S,Aquamarine) >> {
        + Primary ServerAddress
        + Expire time.Time
        + Secondaries []ServerAddress

    }
    class GetReplicasArg << (S,Aquamarine) >> {
        + Handle ChunkHandle

    }
    class GetReplicasReply << (S,Aquamarine) >> {
        + Locations []ServerAddress

    }
    class HeartbeatArg << (S,Aquamarine) >> {
        + Address ServerAddress
        + LeaseExtensions []ChunkHandle
        + AbandondedChunks []ChunkHandle

    }
    class HeartbeatReply << (S,Aquamarine) >> {
        + Garbage []ChunkHandle

    }
    class Lease << (S,Aquamarine) >> {
        + Primary ServerAddress
        + Expire time.Time
        + Secondaries []ServerAddress

    }
    class ListArg << (S,Aquamarine) >> {
        + Path Path

    }
    class ListReply << (S,Aquamarine) >> {
        + Files []PathInfo

    }
    class MkdirArg << (S,Aquamarine) >> {
        + Path Path

    }
    class MkdirReply << (S,Aquamarine) >> {
    }
    class Nouse << (S,Aquamarine) >> {
    }
    class PadChunkArg << (S,Aquamarine) >> {
        + Handle ChunkHandle

    }
    class PadChunkReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode

    }
    class PathInfo << (S,Aquamarine) >> {
        + Name string
        + IsDir bool
        + Length int64
        + Chunks int64

    }
    class PersistentChunkInfo << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + Length Offset
        + Version ChunkVersion
        + Checksum Checksum

    }
    class ReadChunkArg << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + Offset Offset
        + Length int

    }
    class ReadChunkReply << (S,Aquamarine) >> {
        + Data []byte
        + Length int
        + ErrorCode ErrorCode

    }
    class RenameFileArg << (S,Aquamarine) >> {
        + Source Path
        + Target Path

    }
    class RenameFileReply << (S,Aquamarine) >> {
    }
    class ReportSelfArg << (S,Aquamarine) >> {
    }
    class ReportSelfReply << (S,Aquamarine) >> {
        + Chunks []PersistentChunkInfo

    }
    class SendCopyArg << (S,Aquamarine) >> {
        + Handle ChunkHandle
        + Address ServerAddress

    }
    class SendCopyReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode

    }
    class WriteChunkArg << (S,Aquamarine) >> {
        + DataID DataBufferID
        + Offset Offset
        + Secondaries []ServerAddress

    }
    class WriteChunkReply << (S,Aquamarine) >> {
        + ErrorCode ErrorCode
    }
}


namespace master {
    class Master  {
        - address gfs.ServerAddress
        - serverRoot string
        - l net.Listener
        - shutdown <font color=blue>chan</font> <font color=blue>struct</font>{}
        - dead bool
        - nm *namespaceManager
        - cm *chunkManager
        - csm *chunkServerManager

        - initMetadata() 
        - loadMeta() error
        - storeMeta() error
        - serverCheck() error
        - reReplication(handle gfs.ChunkHandle) error

        + Shutdown() 
        + RPCHeartbeat(args gfs.HeartbeatArg, reply *gfs.HeartbeatReply) error
        + RPCGetPrimaryAndSecondaries(args gfs.GetPrimaryAndSecondariesArg, reply *gfs.GetPrimaryAndSecondariesReply) error
        + RPCExtendLease(args gfs.ExtendLeaseArg, reply *gfs.ExtendLeaseReply) error
        + RPCGetReplicas(args gfs.GetReplicasArg, reply *gfs.GetReplicasReply) error
        + RPCCreateFile(args gfs.CreateFileArg, reply *gfs.CreateFileReply) error
        + RPCDeleteFile(args gfs.DeleteFileArg, reply *gfs.DeleteFileReply) error
        + RPCRenameFile(args gfs.RenameFileArg, reply *gfs.RenameFileReply) error
        + RPCMkdir(args gfs.MkdirArg, reply *gfs.MkdirReply) error
        + RPCList(args gfs.ListArg, reply *gfs.ListReply) error
        + RPCGetFileInfo(args gfs.GetFileInfoArg, reply *gfs.GetFileInfoReply) error
        + RPCGetChunkHandle(args gfs.GetChunkHandleArg, reply *gfs.GetChunkHandleReply) error

    }
    class PersistentBlock  {
        + NamespaceTree []serialTreeNode
        + ChunkInfo []serialChunkInfo

    }
    class chunkInfo  {
        - location []gfs.ServerAddress
        - primary gfs.ServerAddress
        - expire time.Time
        - version gfs.ChunkVersion
        - checksum gfs.Checksum
        - path gfs.Path

    }
    class chunkManager  {
        - chunk <font color=blue>map</font>[gfs.ChunkHandle]*chunkInfo
        - file <font color=blue>map</font>[gfs.Path]*fileInfo
        - replicasNeedList []gfs.ChunkHandle
        - numChunkHandle gfs.ChunkHandle

        + Deserialize(files []serialChunkInfo) error
        + Serialize() []serialChunkInfo
        + RegisterReplica(handle gfs.ChunkHandle, addr gfs.ServerAddress, useLock bool) error
        + GetReplicas(handle gfs.ChunkHandle) ([]gfs.ServerAddress, error)
        + GetChunk(path gfs.Path, index gfs.ChunkIndex) (gfs.ChunkHandle, error)
        + GetLeaseHolder(handle gfs.ChunkHandle) (*gfs.Lease, []gfs.ServerAddress, error)
        + ExtendLease(handle gfs.ChunkHandle, primary gfs.ServerAddress) error
        + CreateChunk(path gfs.Path, addrs []gfs.ServerAddress) (gfs.ChunkHandle, []gfs.ServerAddress, error)
        + RemoveChunks(handles []gfs.ChunkHandle, server gfs.ServerAddress) error
        + GetNeedlist() []gfs.ChunkHandle

    }
    class chunkServerInfo  {
        - lastHeartbeat time.Time
        - chunks <font color=blue>map</font>[gfs.ChunkHandle]bool
        - garbage []gfs.ChunkHandle

    }
    class chunkServerManager  {
        - servers <font color=blue>map</font>[gfs.ServerAddress]*chunkServerInfo

        + Heartbeat(addr gfs.ServerAddress, reply *gfs.HeartbeatReply) bool
        + AddChunk(addrs []gfs.ServerAddress, handle gfs.ChunkHandle) 
        + AddGarbage(addr gfs.ServerAddress, handle gfs.ChunkHandle) 
        + ChooseReReplication(handle gfs.ChunkHandle) (gfs.ServerAddress, error)
        + ChooseServers(num int) ([]gfs.ServerAddress, error)
        + DetectDeadServers() []gfs.ServerAddress
        + RemoveServer(addr gfs.ServerAddress) ([]gfs.ChunkHandle, error)

    }
    class fileInfo  {
        - handles []gfs.ChunkHandle

    }
    class namespaceManager  {
        - root *nsTree
        - serialCt int

        - tree2array(array *[]serialTreeNode, node *nsTree) int
        - array2tree(array []serialTreeNode, id int) *nsTree
        - lockParents(p gfs.Path, goDown bool) ([]string, *nsTree, error)
        - unlockParents(ps []string) 

        + Serialize() []serialTreeNode
        + Deserialize(array []serialTreeNode) error
        + PartionLastName(p gfs.Path) (gfs.Path, string)
        + Create(p gfs.Path) error
        + Delete(p gfs.Path) error
        + Rename(source gfs.Path, target gfs.Path) error
        + Mkdir(p gfs.Path) error
        + List(p gfs.Path) ([]gfs.PathInfo, error)

    }
    class nsTree {
        - isDir bool
        - children <font color=blue>map</font>[string]*nsTree
        - length int64
        - chunks int64

    }
    class serialChunkInfo {
        + Path gfs.Path
        + Info []gfs.PersistentChunkInfo

    }
    class serialTreeNode {
        + IsDir bool
        + Children <font color=blue>map</font>[string]int
        + Chunks int64

    }
}
"sync.RWMutex" *-- "master.chunkInfo"
"sync.RWMutex" *-- "master.chunkManager"
"sync.RWMutex" *-- "master.chunkServerManager"
"sync.RWMutex" *-- "master.fileInfo"
"sync.RWMutex" *-- "master.nsTree"


namespace util {
    class ArraySet{
        - arr []<font color=blue>interface</font>{}
        - lock sync.RWMutex

        + Add(element <font color=blue>interface</font>{}) 
        + Delete(element <font color=blue>interface</font>{}) 
        + Size() int
        + RandomPick() <font color=blue>interface</font>{}
        + GetAll() []<font color=blue>interface</font>{}
        + GetAllAndClear() []<font color=blue>interface</font>{}

    }
}

@enduml
